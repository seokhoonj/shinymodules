% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multi.R
\name{multiSingleServer}
\alias{multiSingleServer}
\title{Dynamic Single-Selection Server Module for MultiInput}
\usage{
multiSingleServer(
  id,
  choices = character(0),
  selected = character(0),
  single = TRUE
)
}
\arguments{
\item{id}{Shiny module ID.}

\item{choices}{Character vector of available choices.}

\item{selected}{Character vector of initially selected values
(if more than one, only the first is used in single mode).}

\item{single}{Logical; if \code{TRUE} (default), enforce single selection
with most-recent value kept. If \code{FALSE}, behave like normal multi-select.}
}
\value{
A \code{reactive()} expression returning the selected value(s).
In single mode, this returns a vector of length â‰¤ 1.
}
\description{
Enhances a \code{shinyWidgets::multiInput} widget to behave as a
\emph{single-selection} input. Whenever a new item is selected, all
previous selections are cleared, and only the most recently
selected item remains.

The module prevents intermediate and empty states from propagating
during internal updates by freezing reactive values and using an
internal update lock flag.
}
\details{
\itemize{
\item Tracks previous selection using \code{reactiveVal()}
\item Detects newly added values using set difference (\code{setdiff})
\item Uses \code{freezeReactiveValue()} and an \code{internal} flag to avoid
update loops and transient invalid states
\item Downstream usage should apply \code{req()} for safe access
}
}
\examples{
\dontrun{
# UI
multiUI("sector", label = "Select Sector", choices = c("Tech", "Bio", "Finance"))

# Server
sector_sel <- multiSingleServer("sector", choices = c("Tech", "Bio", "Finance"))

observe({
  req(sector_sel())
  print(sector_sel())
})
}

}
\seealso{
\code{\link[=multiUI]{multiUI()}}
}
